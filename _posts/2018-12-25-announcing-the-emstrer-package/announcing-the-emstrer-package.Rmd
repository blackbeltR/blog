---
title: "Announcing the 'emstreeR' package"
description: |
  Originally published on https://allanvc.github.io
creative_commons: CC BY
author:
  - name: Allan V. C. Quadros
    url: https://allanvc.github.io
date: 12-25-2018
output:
  radix::radix_article:
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Everyone who is addicted to **R** dreams about making his/her first package. An even bigger dream is to make your package available on CRAN - The Comprehensive R Archive Network.

That being said, I am proud to announce that my first R package, **emstreeR** is available on CRAN since the beginning of December.

**emstreeR** is package for fast and easily computing Euclidean Minimum Spanning Trees, using 'mlpack' - the C++ Machine Learning library, which is called on background. **emstreeR** heavily relies on RcppMLPACK and Rcpp, and works as a wrapper, so that R users can benefit from the C++ function for computing an Euclidean Minimum Spanning Tree without actually touching the C++ code. The package also provides functions and an S3 method for readily plotting the Minimum Spanning Trees (MST) using either 'base' R, 'scatterplot3d' or 'ggplot2' style.

Working with **emstreeR** is easy because you just have to pass your matrix or data.frame of points to the main function `computeMST()` in order to things work.

But, before we begin, what exactly is an Minimum Spanning Tree?

In order to explain that, I will try not to bring any graph concept to the discussion.

Imagine you own an airline carrier company that flyes for 10 different cities between Argentina and Brazil. Disregarding other aviation implications (such as the need of always flying in a route that is at a maximum stablished distance of an alternative airport in case of any emergency), you want to know the most efficient flying routes, e.g. the routes that connects all the ten cities with the minimum distance possible. That optimal set of routes is a Minimum Spanning Tree. Therefore, the Minimum Spanning Tree problem is, in its essence, an optimization problem. The distances between the points can be calculated using several methods, such as Manhattan, Euclidean, Minkowski, etc. In **emstreeR**, we use the most common one: Euclidean distances. Hence the name Euclidean Minimum Spanning Trees.

So, let's try to reproduce the aforementioned example. First, we are going to use the package 'ggmap'. We will pass the cities names and then get the latitude and longitude of those cities.

```{r, echo=TRUE}
library(ggmap)

## cities:
cities_location <- data.frame(location = c("Passo Fundo, Brazil", 
                                            "Buenos Aires, Argentina",
                                            "Campinas, Brazil",
                                            "Ribeirao Preto, Brazil",
                                            "Mendoza, Argentina",
                                            "Belo Horizonte, Brazil",
                                            "Brasilia, Brazil",
                                            "Rio de Janeiro, Brazil",
                                            "Campo Grande, Brazil",
                                            "Recife, Brazil"
                                            ), 
                                stringsAsFactors = FALSE)
    
## get latitude and longitude
geo_location <- geocode(cities_location$location, source = "dsk")
    
## combine data:
df_location <- cbind(cities_location, geo_location)
```

Let's plot the map, so we know to where we have to fly:

```{r, preview=FALSE, echo=TRUE, fig.height=4, fig.width=8}
# coordinates for South America
map_grid <- c(left = -75, bottom = -40, right = -30, top = 5) 

library(dplyr) # we wanna use pipes

get_stamenmap(map_grid, zoom = 5) %>% ggmap()+
  geom_point(data = df_location,
           aes(x = lon, y = lat), size=2)
  
```


Now is when **emstreeR** comes in handy. We pass the point columns from the df_location object and it computes the minimum route between the points, or the euclidean minimum spanning tree.


```{r,  echo=TRUE}
## MST:
library(emstreeR)
out <- ComputeMST(df_location[,2:3])

out
```

You can silence the output of the algorithm by setting `verbose=FALSE` in `computeMST()`.

To visualize the result, we plot the map again, but now using the ggplot2's extension provided in **emstreeR**: `stat_MST()`.

```{r, preview=TRUE, fig.height=4, fig.width=8, echo=TRUE}
## Plot:
    
get_stamenmap(map_grid, zoom = 5) %>% ggmap()+
  stat_MST(data = out,
           aes(x = lon, y = lat, from=from, to=to), 
           colour="red", linetype = 2)+
  geom_point(data = out, aes(x = lon, y = lat), size=3)
  
```

Now that you have the information about the minimum route, depending on the number of planes you have, you can choose the regions and cities each plane will fly to. Clustering is another common application of the Minimum Spanning Tree problem. Nonetheless, let's save that topic for another post.

Below, I will show you another cool examples where **emstreeR** comes in handy.

**emstreeR** has an S3 method to the base R function `plot()`. It is easy to make simple 2D plots with that.

```{r, echo=TRUE}
## artifical data for 2D plots:
set.seed(1984)
n <- 15
c1 <- data.frame(x = rnorm(n,-0.2, sd=0.2), y = rnorm(n,-2,sd=0.2))
c2 <- data.frame(x = rnorm(n,-1.1, sd=0.15), y = rnorm(n,-2,sd=0.3)) 
d <- rbind(c1, c2)
d <- as.data.frame(d)
  
## MST:
#library(emstreeR)
out <- ComputeMST(d, verbose = FALSE)  
```

```{r, preview=FALSE, fig.height=5, fig.width=7, echo=TRUE}
## simple 2D plot:
plot(out, col.pts = "red", col.segts = "blue")
```

The `stat_MST()` extension also makes it easy plotting 2D plots in ggplot2 style:

```{r, preview=FALSE, fig.height=5, fig.width=7, echo=TRUE}
## 2D plot with ggplot2:
library(ggplot2)
ggplot(data = out, aes(x = x, y = y, from = from, to = to))+ 
  geom_point()+ 
  stat_MST(colour="red")
```

If you want something fancier, you can use the `geom=curve` argument:

```{r, preview=FALSE, fig.height=5, fig.width=7, echo=TRUE}
## 2D plot with ggplot2:
#library(ggplot2)
ggplot(data = out, aes(x = x, y = y, from=from, to=to))+ 
  geom_point()+ 
  stat_MST(geom="curve")
```

You can also make 3D plots with **emstreeR**. It has a wrapper function to 'scatterplot3D'.

Let's create 3D artificial data and compute the MST:

```{r, echo=TRUE}
## artificial data for 3D plots:
n = 99
set.seed(1984)
d1<-matrix(rnorm(n,mean=-2,sd=.5), n/3, 3) # 3d
d2<-matrix(rnorm(n,mean=0,sd=.3), n/3, 3)
d3<-matrix(rnorm(n,mean=3,sd=.4), n/3, 3)
d<-rbind(d1,d2,d3) # just to show a matrix input
  
## MST:
library(emstreeR)
out <- ComputeMST(d, verbose = FALSE)
```

We can do a simple 3D plot using the function `plotMST3D()`.

```{r, preview=FALSE, fig.height=5, fig.width=7, echo=TRUE}
## simple 3D plot:
plotMST3D(out, xlab = "xaxis", main="Just a MST 3D plot")
```

But if you like fancy things, we can also do some MST 3D plot using plotly:

```{r, preview=FALSE, fig.height=4, fig.width=8, echo=TRUE}

# some adjusts needed
ord_id <- Reduce(rbind, rbind(t(out[, c("from", "to")]), NA))

ord_data <- out[ord_id, c("X1", "X2", "X3")]
ord_data <- as.data.frame(ord_data)


library(dplyr) # we wanna use pipes
library(plotly)

plot_ly(showlegend = T) %>%
  add_markers(data=ord_data, x = ~X1, y = ~X2, z = ~X3, 
              marker=list(opacity=0.5), size = I(3.5), name="points") %>%
  add_paths(data=ord_data, x = ~X1, y = ~X2, z = ~X3, 
            color = I("red"), name="edges")
```


And that's it ! I hope you enjoy **emstreeR**.

* CRAN version: https://cran.r-project.org/package=emstreeR
* Dev version: https://github.com/allanvc/emstreeR

